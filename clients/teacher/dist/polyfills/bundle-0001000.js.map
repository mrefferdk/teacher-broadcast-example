{"version":3,"file":"polyfills/bundle-0001000.js","sources":["webpack:////Users/andreas/frontend/dev-tools/yakintos/node_modules/polyfill-library/polyfills/__dist/_ESAbstract.CreateMethodProperty/raw.js","webpack:////Users/andreas/frontend/dev-tools/yakintos/node_modules/polyfill-library/polyfills/__dist/_ESAbstract.Get/raw.js","webpack:////Users/andreas/frontend/dev-tools/yakintos/node_modules/polyfill-library/polyfills/__dist/_ESAbstract.ToObject/raw.js","webpack:////Users/andreas/frontend/dev-tools/yakintos/node_modules/polyfill-library/polyfills/__dist/Object.assign/raw.js"],"sourcesContent":["\n// _ESAbstract.CreateMethodProperty\n// 7.3.5. CreateMethodProperty ( O, P, V )\nfunction CreateMethodProperty(O, P, V) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Let newDesc be the PropertyDescriptor{[[Value]]: V, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.\n\tvar newDesc = {\n\t\tvalue: V,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true\n\t};\n\t// 4. Return ? O.[[DefineOwnProperty]](P, newDesc).\n\tObject.defineProperty(O, P, newDesc);\n}","\n// _ESAbstract.Get\n// 7.3.1. Get ( O, P )\nfunction Get(O, P) { // eslint-disable-line no-unused-vars\n\t// 1. Assert: Type(O) is Object.\n\t// 2. Assert: IsPropertyKey(P) is true.\n\t// 3. Return ? O.[[Get]](P, O).\n\treturn O[P];\n}","\n// _ESAbstract.ToObject\n// 7.1.13 ToObject ( argument )\n// The abstract operation ToObject converts argument to a value of type Object according to Table 12:\n// Table 12: ToObject Conversions\n/*\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| Argument Type | Result                                                                                                                             |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n| Undefined     | Throw a TypeError exception.                                                                                                       |\n| Null          | Throw a TypeError exception.                                                                                                       |\n| Boolean       | Return a new Boolean object whose [[BooleanData]] internal slot is set to argument. See 19.3 for a description of Boolean objects. |\n| Number        | Return a new Number object whose [[NumberData]] internal slot is set to argument. See 20.1 for a description of Number objects.    |\n| String        | Return a new String object whose [[StringData]] internal slot is set to argument. See 21.1 for a description of String objects.    |\n| Symbol        | Return a new Symbol object whose [[SymbolData]] internal slot is set to argument. See 19.4 for a description of Symbol objects.    |\n| Object        | Return argument.                                                                                                                   |\n|----------------------------------------------------------------------------------------------------------------------------------------------------|\n*/\nfunction ToObject(argument) { // eslint-disable-line no-unused-vars\n\tif (argument === null || argument === undefined) {\n\t\tthrow TypeError();\n\t}\n  return Object(argument);\n}","\n// Object.assign\n// 19.1.2.1 Object.assign ( target, ...sources )\nCreateMethodProperty(Object, 'assign', function assign(target, source) { // eslint-disable-line no-unused-vars\n\t// 1. Let to be ? ToObject(target).\n\tvar to = ToObject(target);\n\n\t// 2. If only one argument was passed, return to.\n\tif (arguments.length === 1) {\n\t\treturn to;\n\t}\n\n\t// 3. Let sources be the List of argument values starting with the second argument\n\tvar sources = Array.prototype.slice.call(arguments, 1);\n\n\t// 4. For each element nextSource of sources, in ascending index order, do\n\tvar index1;\n\tvar index2;\n\tvar keys;\n\tvar from;\n\tfor (index1 = 0; index1 < sources.length; index1++) {\n\t\tvar nextSource = sources[index1];\n\t\t// a. If nextSource is undefined or null, let keys be a new empty List.\n\t\tif (nextSource === undefined || nextSource === null) {\n\t\t\tkeys = [];\n\t\t\t// b. Else,\n\t\t} else {\n\t\t\t// i. Let from be ! ToObject(nextSource).\n\t\t\tfrom = ToObject(nextSource);\n\t\t\t// ii. Let keys be ? from.[[OwnPropertyKeys]]().\n\t\t\t/*\n\t\t\t\tThis step in our polyfill is not complying with the specification.\n\t\t\t\t[[OwnPropertyKeys]] is meant to return ALL keys, including non-enumerable and symbols.\n\t\t\t\tTODO: When we have Reflect.ownKeys, use that instead as it is the userland equivalent of [[OwnPropertyKeys]].\n\t\t\t*/\n\t\t\tkeys = Object.keys(from);\n\t\t}\n\n\t\t// c. For each element nextKey of keys in List order, do\n\t\tfor (index2 = 0; index2 < keys.length; index2++) {\n\t\t\tvar nextKey = keys[index2];\n\t\t\t// i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n\t\t\tvar desc = Object.getOwnPropertyDescriptor(from, nextKey);\n\t\t\t// ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n\t\t\tif (desc !== undefined && desc.enumerable) {\n\t\t\t\t// 1. Let propValue be ? Get(from, nextKey).\n\t\t\t\tvar propValue = Get(from, nextKey);\n\t\t\t\t// 2. Perform ? Set(to, nextKey, propValue, true).\n\t\t\t\tto[nextKey] = propValue;\n\t\t\t}\n\t\t}\n\t}\n\t// 5. Return to.\n\treturn to;\n});"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","sourceRoot":""}